<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/assets/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/assets/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/assets/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/assets/css/article.css" type="text/css">

	
	<link rel="icon" href="/assets/images/favicon.png">

	<title>Chapter 2 - The Data Store and Data Classes</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="This chapter looks at structuring the access to the data store and data classes." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="Chapter 2 - The Data Store and Data Classes" />
        <meta property="og:description" content="This chapter looks at structuring the access to the data store and data classes." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/Tags" class="btn btn-link text-light">Tags</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 13-Aug-2021</div>
                <div class="mb-2">Updated: 13-Aug-2021</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#irecord">IRecord</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-weatherforecast-data-classes">The WeatherForecast Data Classes</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#the-data-store">The Data Store</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#data-brokers">Data Brokers</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#testing">Testing</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#summary">Summary</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>Chapter 2 - The Data Store and Data Classes</h1>
            <div><small>This chapter looks at structuring the access to the data store and data classes.</small></div></div>
    <div class="mb-2"><h3>Document List</h3>
        <ul><li><a href="/Stories/A-Blazor-Database-Primer/Index.html">A Blazor Database Primer</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-1.html">Chapter 1 - Project Design and Structure</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-2.html">Chapter 2 - The Data Store and Data Classes</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-3.html">Chapter 3 - The Business and Application Code</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-4.html">Chapter 4 - Setting up the Solution to Run</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-5.html">Chapter 5 - Adding a WASM SPA to the Solution</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-6.html">Chapter 6 -  Rebuilding FetchData</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-7.html">Chapter 7 - Adding Sorting and Paging to the List Form</a></li></ul></div>
    <div class="md-danger">
        This set of articles and code base is out of date. They don't reflect my current framework. Use them at your risk.
    </div>
    <p>Data is retrieved from data stores into data classes.  We apply some rules to our data classes so we can write a lot of boilerplate code for data handling:</p>
<ol>
<li>All data classes implement a <code>IRecord</code> interface.  This defines properties all data classes must implement.</li>
<li>All Data classes must be immutable and there implemented as <code>records</code>.  Specific edit classes will be used in edit operations.</li>
<li>All data classes and their data store datasets use the same names.</li>
</ol>
<p>In which domain do data classes belong?</p>
<p>The initial answer is Data Domain.  However, application logic code uses the data classes.  As core code can't depend on Data, data classes belong in the Core Domain.  I'll discuss more complex examples in a later chapter where we have multiple data classes representing the same data set and where those live.</p>
<h2 id="irecord">IRecord</h2>
<p>Add a <code>IRecord</code> public interface to <em>Blazr.Primer.Core/Interfaces</em>.</p>
<pre><code class="language-csharp">using System;
namespace Blazr.Primer.Core
{
    public interface IRecord
    {
        public Guid ID { get; }
        public string Name { get; }
    }
}
</code></pre>
<p>All dataclasses implement this interface.  They must have:</p>
<ol>
<li>An <code>ID</code> field of type <code>Guid</code>.</li>
<li>A <code>Name</code> field of type <code>string</code>.</li>
</ol>
<h2 id="the-weatherforecast-data-classes">The WeatherForecast Data Classes</h2>
<p>Move <code>WeatherForecast</code> from <em>Blazr.Primer/data</em> to <em>Blazr.Primer.Core/DataClasses</em>.</p>
<p>Modify <code>WeatherForecast</code> to:</p>
<pre><code class="language-csharp">using System;

namespace Blazr.Primer.Core
{
    public record WeatherForecast : IRecord
    {
        public Guid ID { get; init; } = Guid.Empty;
        public DateTime Date { get; init; }
        public int TemperatureC { get; init; }
        public string Summary { get; init; }
        public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
        public string Name =&gt; $&quot;Weather Forecast for {Date.ToShortDateString()}&quot;;
    }
}
</code></pre>
<p>We've:</p>
<ol>
<li>Added the <code>IRecord</code> interface.</li>
<li>Implemented <code>ID</code> and <code>Name</code>.</li>
<li>Changed from a <code>class</code> to a <code>record</code>.</li>
<li>Changed the setters to <code>init</code>.</li>
</ol>
<h2 id="the-data-store">The Data Store</h2>
<p>To get started, We're building an in-memory data store that &quot;mimics&quot; a Entity Framework context.  We'll look at a real SQL implementation using Entity Framework in a later chapter.</p>
<p>Add a <code>DB</code> folder to <em>BlazorDB.Data</em>, and add a <code>WeatherDataStore</code> class.</p>
<pre><code class="language-csharp">using Blazr.Primer.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;

namespace Blazr.Primer.Data
{
    public class WeatherDataStore
    {
        // field holding the internal &quot;table&quot; of weatherforecast records
        private List&lt;_WeatherForecast&gt; _weatherForecastRecords = new List&lt;_WeatherForecast&gt;();

        public WeatherDataStore()
            =&gt; _weatherForecastRecords = _getForecasts();

        // The Dataset for WeatherForecasts
        public IEnumerable&lt;WeatherForecast&gt; WeatherForecast
        {
            get
            {
                var list = new List&lt;WeatherForecast&gt;();
                _weatherForecastRecords.ForEach(item =&gt; list.Add(new WeatherForecast { ID = item.ID, Date = item.Date, TemperatureC = item.TemperatureC, Summary = item.Summary }));
                return list.AsEnumerable&lt;WeatherForecast&gt;();
            }
        }

        // Generics method to get the correct dataset for TRecord
        public ValueTask&lt;List&lt;TRecord&gt;&gt; GetDataSet&lt;TRecord&gt;() where TRecord : class, IRecord, new()
        {

            var dbSetName = new TRecord().GetType().Name;
            // Get the property info object for the DbSet 
            var pinfo = this.GetType().GetProperty(dbSetName);
            List&lt;TRecord&gt; dbSet = null;
            Debug.Assert(pinfo != null);
            // Get the property DbSet
            try
            {
                dbSet = (List&lt;TRecord&gt;)pinfo.GetValue(this);
            }
            catch
            {
                throw new InvalidOperationException($&quot;{dbSetName} does not have a matching DBset &quot;);
            }
            Debug.Assert(dbSet != null);
            Task.Delay(100);
            return ValueTask.FromResult(dbSet);
        }

        //  Internal Read/Write class for a WeatherForecast
        private struct _WeatherForecast
        {
            public Guid ID;
            public DateTime Date;
            public int TemperatureC;
            public string Summary;
        }

        // method to build the internal WeatherForecast &quot;table&quot;
        private List&lt;_WeatherForecast&gt; _getForecasts()
        {
            var rng = new Random();
            var summaries = new[]  {
                &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;
            };
            return Enumerable.Range(1, 50).
                    Select(index =&gt; new _WeatherForecast
                    {
                        ID = Guid.NewGuid(),
                        Date = DateTime.Now.AddDays(index),
                        TemperatureC = rng.Next(-20, 55),
                        Summary = summaries[rng.Next(summaries.Length)]
                    }).ToList();
        }

        // method to seed the Data Store WesatherForecast dataset with a known dataset
        public void OverrideWeatherForecastDateSet(List&lt;WeatherForecast&gt; list)
        {
            this._weatherForecastRecords.Clear();
            list.ForEach(item =&gt; this._weatherForecastRecords.Add(new _WeatherForecast { ID = item.ID, Date = item.Date, TemperatureC = item.TemperatureC, Summary = item.Summary }));
        }
    }
}
</code></pre>
<p>The class builds an internal list of records on initialisation.  See the inline comments for details.  The public <code>WeatherForcast</code> property provides an <code>IEnumerable</code> list of <code>WeatherForecast</code> records from the internal store.  By convention the data store <em>dataset</em> is always named the same as the record class.  Using this convention, the generic method <code>List&lt;TRecord&gt; GetDataSet&lt;TRecord&gt;()</code> gets the correct <code>IEnumerable&lt;TRecord&gt;</code> property for <code>TRecord</code>.  In our case we only have one, but we're building the logic to make this scaleable.</p>
<p>Most of the code is self evident, but <code>GetDataSet</code> uses some advanced programming techniques using <code>Reflection</code> so we'll look at it in detail:</p>
<pre><code class="language-csharp">public ValueTask&lt;List&lt;TRecord&gt;&gt; GetDataSet&lt;TRecord&gt;() where TRecord : class, IRecord, new()
</code></pre>
<p>The declaration uses generics.  We define that <code>TRecord</code> must:</p>
<ol>
<li>Be a class (or record).</li>
<li>Must implement <code>IRecord</code>.</li>
<li>Must implement and empty constructor.</li>
</ol>
<p>Normal database operations as asynchronous, so we wrap the code in a <code>ValueTask</code> and we return a &quot;dataset&quot;, which in this case is a  <code>List</code> of <code>TRecords</code>.</p>
<p>Let's look at a real call into the data store:</p>
<pre><code class="language-csharp">var dbset = await dataStore.GetDataSet&lt;WeatherForecast&gt;();
</code></pre>
<p><code>new TRecord()</code> constructs a new copy of <code>WeatherForecast</code>. <code>.GetType().Name</code> gets the class name.  In our case <code>WeatherForecast</code>.</p>
<pre><code class="language-csharp">var dbSetName = new TRecord().GetType().Name;
</code></pre>
<p><code>this.GetType().GetProperty(dbSetName)</code> gets the datastore <code>Type</code> and then gets the <code>PropertyInfo</code> object with the name we retrieved above, in our case <code>WeatherForecast</code>.</p>
<pre><code class="language-csharp">var pinfo = this.GetType().GetProperty(dbSetName);
</code></pre>
<p>Finally we get the value of <code>pinfo</code> for this instance of the data store.  <code>GetValue</code> returns an <code>object</code>, so we cast it to what we know it is a <code>List</code> of <code>TRecord</code>.</p>
<pre><code class="language-csharp">dbSet = (List&lt;TRecord&gt;)pinfo.GetValue(this);
</code></pre>
<h2 id="data-brokers">Data Brokers</h2>
<p>Data Brokers are the external interface for the <strong>Data Domain</strong> black box.  The <strong>Core Domain</strong> uses brokers to make calls into the <strong>Data Domain</strong>.  They're often known as <em>shims</em>, skinny one line method classes.  While the data brokers themselves reside in the <strong>Data Domain</strong>, the interface is used by the <strong>Core Domain</strong> and thus resides there.</p>
<h3 id="idatabroker">IDataBroker</h3>
<p>Add <code>IDataBroker</code> interface to <em>Blazr.Primer.Core/Interfaces</em>.</p>
<pre><code class="language-csharp">using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazr.Primer.Core
{
    public interface IDataBroker
    {
        public ValueTask&lt;List&lt;TRecord&gt;&gt; SelectAllRecordsAsync&lt;TRecord&gt;() where TRecord : class, IRecord, new();
    }
}
</code></pre>
<p>Normally this would implement a full set of CRUD methods, but at the moment we're only doing the List operation, so define a single method <code>SelectAllRecordsAsync</code>.</p>
<p>It's:</p>
<ol>
<li>Generic using <code>TRecord</code> which has constraints - it must be a class (or record), implement <code>IRecord</code> and have an empty constructor.</li>
<li>Returns a <code>ValueTask</code>, so can be async.  Almost all database operations are async, so we start out implementing the broker using Task based methods.</li>
<li>Returns a <code>List</code> of <code>TRecord</code>s.</li>
</ol>
<h3 id="databroker">DataBroker</h3>
<p>This is the base interface definition.  It resides in the <strong>Data Domain</strong>.</p>
<p>Add a <em>Broker</em> folder to <em>BlazorDB.Core</em>, and add a <code>DataBroker</code> class.</p>
<pre><code class="language-csharp">using Blazr.Primer.Core;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazr.Primer.Data
{
    public abstract class DataBroker : IDataBroker
    {
        public virtual ValueTask&lt;List&lt;TRecord&gt;&gt; SelectAllRecordsAsync&lt;TRecord&gt;() where TRecord : class, IRecord, new()
            =&gt; throw new InvalidOperationException($&quot;The SelectAllRecordsAsync method is not implemented for this Broker.&quot;);
    }
}
</code></pre>
<p>It doesn't do a great deal, just returns an exception.  In full Crud operations it implements all the CRUD methods.  Specific implementations then only need to override relevant methods, and rely on the base implement to return &quot;Not Implemented&quot; exceptions.</p>
<h3 id="serverdatabroker">ServerDataBroker</h3>
<p>Finally a real implementation.</p>
<p>Add a <em>Broker</em> folder to <em>BlazorDB.Core</em>, and add a <code>ServerDataBroker</code> class.</p>
<pre><code class="language-csharp">using Blazr.Primer.Core;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazr.Primer.Data
{
    public class ServerDataBroker : DataBroker, IDataBroker
    {
        // internal field for the data store
        private WeatherDataStore dataStore;

        // Initialization - get passed the weatherForecastDataStore
        //  As a service we will get this passed to us by the Service Container
        public ServerDataBroker(WeatherDataStore weatherForecastDataStore)
        {
            this.dataStore = weatherForecastDataStore;
        }

        // Concrete implementation getting all the records from the data store
        public async override ValueTask&lt;List&lt;TRecord&gt;&gt; SelectAllRecordsAsync&lt;TRecord&gt;()
        {
            var dbset = await dataStore.GetDataSet&lt;TRecord&gt;();
            return dbset;
        }
    }
}
</code></pre>
<p>This uses generics and the naming conventions to get the correct DataSet for <code>TRecord</code>.</p>
<h2 id="testing">Testing</h2>
<p>At this point we can set up our first test.</p>
<p>First we need a WeatherForecast utility class to build test <code>WeatherForecast</code> data sets.</p>
<pre><code class="language-csharp">// Directory: BlazorDb.Test/Base
using Blazr.Primer.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Blazr.Primer.Test
{
    internal static class WeatherForcastHelper
    {
        public static ValueTask&lt;List&lt;WeatherForecast&gt;&gt; CreateRandomWeatherForecastListAsync(int number)
            =&gt; ValueTask.FromResult(CreateRandomWeatherForecastList(number));

        public static ValueTask&lt;List&lt;WeatherForecast&gt;&gt; CreateWeatherForecastListAsync(List&lt;WeatherForecast&gt; list)
            =&gt; ValueTask.FromResult&lt;List&lt;WeatherForecast&gt;&gt;(list);

        public static List&lt;WeatherForecast&gt; CreateFixedWeatherForecastList(int number)
            =&gt; Enumerable.Range(1, number).
                 Select(index =&gt; FixedWeatherForcast).ToList();

        public static WeatherForecast FixedWeatherForcast
            =&gt; new WeatherForecast
            {
                ID = Guid.NewGuid(),
                Date = DateTime.Now,
                TemperatureC = 20,
                Summary = &quot;Hot&quot;
            };

        public static List&lt;WeatherForecast&gt; CreateRandomWeatherForecastList(int number)
        {
            var rng = new Random();
            var summaries = new[]  {
                    &quot;Freezing&quot;, &quot;Bracing&quot;, &quot;Chilly&quot;, &quot;Cool&quot;, &quot;Mild&quot;, &quot;Warm&quot;, &quot;Balmy&quot;, &quot;Hot&quot;, &quot;Sweltering&quot;, &quot;Scorching&quot;
                };
            var list = Enumerable.Range(1, number).
                 Select(index =&gt; new WeatherForecast
                 {
                     ID = Guid.NewGuid(),
                     Date = DateTime.Now.AddDays(index),
                     TemperatureC = rng.Next(-20, 55),
                     Summary = summaries[rng.Next(summaries.Length)]
                 }).ToList();
            return list;
        }
    }
}
</code></pre>
<p>Add a <code>DataBrokerTests</code> class.</p>
<pre><code class="language-csharp">// Directory: BlazorDb.Test/Unit
using Blazr.Primer.Test;
using Blazr.Primer.Core;
using Blazr.Primer.Data;
using System.Collections.Generic;
using Xunit;

namespace Blazr.Primer.Tests
{
    public class DataBrokerTests
    {
        [Fact]
        public async void DataBrokerShouldGetDataStoreWeatherForecastsAsync()
        {
            // define
            int DataStoreRecords = 50;
            var records = WeatherForcastUtils.CreateRandomWeatherForecastList(DataStoreRecords);
            var weatherForecastDataStore = new WeatherDataStore();
            weatherForecastDataStore.OverrideWeatherForecastDateSet(records);
            var dataBroker = new ServerDataBroker(weatherForecastDataStore: weatherForecastDataStore);

            // test
            var retrievedRecords = await dataBroker.SelectAllRecordsAsync&lt;WeatherForecast&gt;();

            // assert
            Assert.IsType&lt;List&lt;WeatherForecast&gt;&gt;(retrievedRecords);
            Assert.Equal(DataStoreRecords, retrievedRecords.Count);
        }
    }
}
</code></pre>
<p>Our data store builds a 50 record dataset, so we can test if:</p>
<ol>
<li>We get a <code>List&lt;WeatherForecast&gt;</code> as our return object - we get a list of the correct records type.</li>
<li>We get 50 rows.</li>
</ol>
<p>On the project you can now run the test and make sure it passes.  Check the errors and debug if you have problems.</p>
<p><img src="/siteimages/articles/DB-Primer/Chapter-2-UnitTests.png" alt="Unit Testing" /></p>
<h2 id="summary">Summary</h2>
<p>We have built our <em>Data Domain</em> code and used <em>xUnit</em> to test the code.  We don't need a fully functional Blazor application to test our unit test our services.</p>
<p>The current Blazor solution uses the code we built in Chapter 1.  None of the above code will be used.</p>
</div></div></div></body></html>





