<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<base href="/">

	

	

	
	<link href="/assets/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

	
	<link href="/assets/css/sb-admin-2.css" rel="stylesheet" type="text/css">
	<link href="/assets/css/site.css" rel="stylesheet" type="text/css">

	
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
	<link rel="stylesheet" href="/assets/css/article.css" type="text/css">

	
	<link rel="icon" href="/assets/images/favicon.png">

	<title>Chapter 3 - The Business and Application Code</title>
        <meta property="author" content="Shaun Curtis" />
        <meta property="description" content="This chapter looks at structuring the business logic and application code." />
    <meta property="og:site_name" content="Cold Elm Coders" />
        <meta property="og:site" content="https://shauncurtis.github.io/" />
        <meta property="og:title" content="Chapter 3 - The Business and Application Code" />
        <meta property="og:description" content="This chapter looks at structuring the business logic and application code." /></head>
<body><header class="navbar bg-dark p-2 text-large text-light"><section class="navbar-section  text-light"><a href="/" class="navbar-brand mr-2 text-large text-light p-2">Cold Elm Coders</a>
			<a href="/Posts" class="btn btn-link text-light">Posts</a>
			<a href="/Rants" class="btn btn-link text-light">Rants</a>
			<a href="/Articles" class="btn btn-link text-light">Articles</a>
			<a href="/Stories" class="btn btn-link text-light">Stories</a>
			<a href="/Tags" class="btn btn-link text-light">Tags</a></section></header>

	<div class="container-fluid"><div class="row"><div class="col-12 col-sm-3 col-lg-2 bg-light pt-2"><div class="article-info p-2"><div class="mb-2">Published: 13-Aug-2021</div>
                <div class="mb-2">Updated: 13-Aug-2021</div>
                <div class="mb-2">Author: Shaun Curtis</div></div>
    <h4 class="p-2">Table of Contents</h4>
<ul class="TOC" >
<li class="TOC-item TOC-item-0" >
<a class="TOC-link" href="#">Top</a>
<ul class="TOC TOC-0" >
<li class="TOC-item TOC-item-1" >
<ul class="TOC TOC-1" >
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#data-connectors">Data Connectors</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#view-services">View Services</a>
</li>
<li class="TOC-item TOC-item-2" >
<a class="TOC-link" href="#system-testing">System Testing</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
			
			<div class="col-12 col-sm-9 col-lg-10 p-2"><div class="pt-2 pb-2 border-bottom mb-4 text-primary"><h1>Chapter 3 - The Business and Application Code</h1>
            <div><small>This chapter looks at structuring the business logic and application code.</small></div></div>
    <div class="mb-2"><h3>Document List</h3>
        <ul><li><a href="/Stories/A-Blazor-Database-Primer/Index.html">A Blazor Database Primer</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-1.html">Chapter 1 - Project Design and Structure</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-2.html">Chapter 2 - The Data Store and Data Classes</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-3.html">Chapter 3 - The Business and Application Code</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-4.html">Chapter 4 - Setting up the Solution to Run</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-5.html">Chapter 5 - Adding a WASM SPA to the Solution</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-6.html">Chapter 6 -  Rebuilding FetchData</a></li><li><a href="/Stories/A-Blazor-Database-Primer/Chapter-7.html">Chapter 7 - Adding Sorting and Paging to the List Form</a></li></ul></div>
    <p>Before writing <strong>Core Domain</strong> code, it's important to understand one overriding principle - Core code has no dependancies on the other project domains.  If you need a dependancy:</p>
<ol>
<li>Your code doesn't belong in the core.</li>
<li>The dependancy needs to move into the core.</li>
<li>You need to re-design your functionality implementation.</li>
</ol>
<p>The &quot;No dependancy&quot; rule is sacrosanct!</p>
<h2 id="data-connectors">Data Connectors</h2>
<p>Data Connectors are the data facing interface of the <strong>Core Domain</strong> black box.  Data connectors talk to data brokers.</p>
<h3 id="idataconnector">IDataConnector</h3>
<p>All data connectors implement  the <code>IDataConnector</code> interface.</p>
<pre><code class="language-csharp">\\ directory: Blazr.Primer.Core\Interfaces
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazr.Primer.Core
{
    public interface IDataConnector
    {
        public ValueTask&lt;List&lt;TRecord&gt;&gt; GetRecordsAsync&lt;TRecord&gt;() where TRecord : class, IRecord, new();
    }
}
</code></pre>
<h3 id="dataconnector">DataConnector</h3>
<p><code>DataConnector</code> implements <code>IDataConnector</code>.  It takes an <code>IDataBroker</code> and calls methods on <code>IDataBroker</code> to get/post it's data.</p>
<pre><code class="language-csharp">\\ directory: Blazr.Primer.Core\Connectors
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazr.Primer.Core
{
    public class DataConnector : IDataConnector
    {

        private IDataBroker dataBroker;

        public DataConnector(IDataBroker dataBroker)
            =&gt; this.dataBroker = dataBroker;

        public ValueTask&lt;List&lt;TRecord&gt;&gt; GetRecordsAsync&lt;TRecord&gt;() where TRecord: class, IRecord, new() 
            =&gt; dataBroker.SelectAllRecordsAsync&lt;TRecord&gt;();
    }
}
</code></pre>
<p>Each method uses generics, so there is no need for specific data connectors for each data class.  To get the <code>WeatherForecast</code> record dataset call:</p>
<pre><code class="language-csharp">var records = GetRecordsAsync&lt;WeatherForecast&gt;();
</code></pre>
<h3 id="testing">Testing</h3>
<p>Add a <code>DataConnectorTests</code> class.</p>
<pre><code class="language-csharp">// Directory: Blazr.Primer.Test/Unit
using Blazr.Primer.Core;
using Moq;
using System.Collections.Generic;
using Xunit;

namespace Blazr.Primer.Test
{
    public partial class DataConnectorTests
    {

        [Fact]
        public async void DataConnectorShouldGet25WeatherForecastsAsync()
        {
            // define
            var noOfRecords = 25;

            var dataBrokerMock = new Mock&lt;IDataBroker&gt;();
            var dataConnector = new DataConnector(dataBroker: dataBrokerMock.Object);
            dataBrokerMock.Setup(broker =&gt;
                broker.SelectAllRecordsAsync&lt;WeatherForecast&gt;())
               .Returns(WeatherForecastHelper.CreateRandomWeatherForecastListAsync(noOfRecords)
               );

            // test
            var retrievedRecords = await dataConnector.GetRecordsAsync&lt;WeatherForecast&gt;();

            // assert
            Assert.IsType&lt;List&lt;WeatherForecast&gt;&gt;(retrievedRecords);
            Assert.Equal(noOfRecords, retrievedRecords.Count);
            dataBrokerMock.Verify(broker =&gt; broker.SelectAllRecordsAsync&lt;WeatherForecast&gt;(), Times.Once);
            dataBrokerMock.VerifyNoOtherCalls();
        }
    }
}
</code></pre>
<p>This test uses <code>Mock</code> to mock the IDataBroker so we can monitor calls into the interface.  The test:</p>
<ol>
<li>Checks the type of the return is <code>List&lt;WeatherForecast&gt;</code>.</li>
<li>Checks we have 25 records - what was created in the mock.</li>
<li>Verifies the <code>IDataBroker</code> method <code>SelectAllRecordsAsync</code> was called only once.</li>
<li>Verifies no other method was called on <code>IDataBroker</code>.</li>
</ol>
<h2 id="view-services">View Services</h2>
<p>View Services are the basic building blocks for the Application/Business logic.</p>
<h3 id="iviewservice">IViewService</h3>
<p>Add an <code>IViewService</code> interface to <em>Blazr.Primer.Core/Interfaces</em></p>
<pre><code class="language-csharp">using Blazorr.Primer.Core;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazr.Primer.Core
{
    public interface IViewService&lt;TRecord&gt;
        where TRecord : class, IRecord, new()
    {
        public List&lt;TRecord&gt; Records { get; }
        public bool HasRecords { get; }
        public int RecordCount { get; }
        public event EventHandler RecordListHasChanged;
        public ValueTask GetRecordsAsync();
    }
}
</code></pre>
<h3 id="viewservice">ViewService</h3>
<p>Add a <code>ViewService</code> class to <em>Blazr.Primer.Core/ViewServices</em>.  This is the base implementation.</p>
<p>The code is self evident.  <code>RecordListHasChanged</code> is triggered when the <code>Records</code> property is updated.</p>
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Blazr.Primer.Core
{
    public class ViewService&lt;TRecord&gt; :
        IViewService&lt;TRecord&gt;,
        IDisposable
        where TRecord : class, IRecord, new()
    {
        private IDataConnector dataConnector;

        public List&lt;TRecord&gt; Records
        {
            get =&gt; _records;

            protected set
            {
                _records = value;
                this.RecordListHasChanged?.Invoke(value, EventArgs.Empty);
            }
        }

        public bool HasRecordList =&gt; Records is not null;

        public bool HasRecords =&gt; this.RecordCount &gt; 0;

        public int RecordCount =&gt; this.Records?.Count ?? 0;

        private List&lt;TRecord&gt; _records;

        public event EventHandler RecordListHasChanged;

        public ViewService(IDataConnector dataConnector)
            =&gt;  this.dataConnector = dataConnector;

        public async ValueTask GetRecordsAsync()
            =&gt;  Records = await dataConnector.GetRecordsAsync&lt;TRecord&gt;();

        public void Dispose() { }
    }
}
</code></pre>
<h3 id="weatherforecastviewservice">WeatherForecastViewService</h3>
<p>Finally we add a concrete implementation of the View Service for the <code>WeatherForecast</code> record.</p>
<pre><code class="language-csharp">namespace Blazr.Primer.Core
{
    public class WeatherForecastViewService : ViewService&lt;WeatherForecast&gt;
    {
        public WeatherForecastViewService(IDataConnector dataConnector) : base(dataConnector) { }
    }
}
</code></pre>
<p>This is minimlistic, just setting <code>IRecord</code> as <code>WeatherForecast</code>.</p>
<h3 id="testing-1">Testing</h3>
<p>Add a <code>ViewServiceTests</code> class</p>
<pre><code class="language-csharp">// Directory: Blazr.Primer.Test/Unit
using Blazr.Primer.Core;
using Moq;
using System;
using System.Collections.Generic;
using Xunit;

namespace Blazr.Primer.Test
{
    public class ViewServiceTests
    {
        [Fact]
        public async void ViewShouldGetWeatherForecastsAsync()
        {
            // define
            var rand = new Random();
            var noOfRecords = rand.Next(25, 250);
            var dataConnectorMock = new Mock&lt;IDataConnector&gt;();
            var weatherForecastViewService = new WeatherForecastViewService(dataConnector: dataConnectorMock.Object);
            //TODO - need to add paging and count returns
            dataConnectorMock.Setup(item =&gt;
                item.GetRecordsAsync&lt;WeatherForecast&gt;())
               .Returns(WeatherForecastHelper.CreateRandomWeatherForecastListAsync(noOfRecords)
               );
            object eventSender = null;
            weatherForecastViewService.RecordListHasChanged += (sender, e) =&gt; { eventSender = sender; };

            // test
            await weatherForecastViewService.GetRecordsAsync();

            // assert
            Assert.IsType&lt;List&lt;WeatherForecast&gt;&gt;(weatherForecastViewService.Records);
            Assert.Equal(noOfRecords, weatherForecastViewService.RecordCount);
            Assert.IsType&lt;List&lt;WeatherForecast&gt;&gt;(eventSender);
            dataConnectorMock.Verify(item =&gt; item.GetRecordsAsync&lt;WeatherForecast&gt;(), Times.Once);
            dataConnectorMock.VerifyNoOtherCalls();
        }

    }
}
</code></pre>
<p>This test uses <code>Mock</code> to mock the IDataConnector so we can monitor calls into the interface.  The test:</p>
<ol>
<li>Checks the type of the return is <code>List&lt;WeatherForecast&gt;</code>.</li>
<li>Checks we have 25 records - what was created in the mock.</li>
<li>Checks the event returns a <code>List&lt;WeatherForecast&gt;</code>.</li>
<li>Verifies the <code>IDataConnector</code> method <code>GetRecordsAsync</code> was called only once.</li>
<li>Verifies no other method was called on <code>IDataConnector</code>.</li>
</ol>
<h2 id="system-testing">System Testing</h2>
<p>We can now do an end to end test on our data stream.</p>
<p>Add a <code>SystemTests</code> class</p>
<pre><code class="language-csharp">// Directory: Blazr.Primer.Test/System
using Blazr.Primer.Core;
using Blazr.Primer.Data;
using System;
using System.Collections.Generic;
using Xunit;

namespace Blazr.Primer.Test
{
    public class SystemTests
    {
        [Fact]
        public async void ViewShouldGet50WeatherForecastsAsync()
        {
            // define
            var rand = new Random();
            var noOfRecords = rand.Next(25, 250);
            var records = await WeatherForecastHelper.CreateRandomWeatherForecastListAsync(noOfRecords);
            var weatherForecastDataStore = new WeatherDataStore();
            weatherForecastDataStore.OverrideWeatherForecastDateSet(records);
            var dataBroker = new ServerDataBroker(weatherForecastDataStore: weatherForecastDataStore);
            var dataConnector = new DataConnector(dataBroker: dataBroker);
            var weatherForecastViewService = new WeatherForecastViewService(dataConnector: dataConnector);
            object eventSender = null;
            weatherForecastViewService.RecordListHasChanged += (sender, e) =&gt; { eventSender = sender; };

            // test
            await weatherForecastViewService.GetRecordsAsync();

            // assert
            Assert.IsType&lt;List&lt;WeatherForecast&gt;&gt;(weatherForecastViewService.Records);
            Assert.Equal(noOfRecords, weatherForecastViewService.RecordCount);
            Assert.IsType&lt;List&lt;WeatherForecast&gt;&gt;(eventSender);
        }
    }
}
</code></pre>
<p>The test:</p>
<ol>
<li>Builds a random data set.</li>
<li>Checks the type of the return is <code>List&lt;WeatherForecast&gt;</code>.</li>
<li>Checks we have <code>noOfRecords</code> records - what was created.</li>
<li>Checks the event returns a <code>List&lt;WeatherForecast&gt;</code>.</li>
<li>Verifies We have the correct number of records.</li>
<li>Verifies RecordListHasChanged was called and returned a <code>List&lt;WeatherForecast&gt;</code>.</li>
</ol>
</div></div></div></body></html>





